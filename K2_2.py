# -*- coding: utf-8 -*-
"""CLTV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cZ1G2Vztx6SpZgQUSuAHh2g3Uix2T1_j
"""

import pandas as pd
import datetime as dt
from lifetimes import BetaGeoFitter
from lifetimes import GammaGammaFitter

def replace_with_thresholds(dataframe, variable):
    """
    Belirli bir değişkendeki aykırı değerleri alt ve üst çeyreklik eşiklerle değiştirir.
    Eğer sütun DataFrame'de yoksa işlem yapmaz.
    """
    if variable in dataframe.columns:
        low_limit = dataframe[variable].quantile(0.01)
        up_limit = dataframe[variable].quantile(0.99)
        dataframe.loc[(dataframe[variable] < low_limit), variable] = round(low_limit, 2)
        dataframe.loc[(dataframe[variable] > up_limit), variable] = round(up_limit, 2)

def create_cltv_df(dataframe,
                   customer_id_col='Customer_ID',
                   timestamp_col='Timestamp',
                   total_price_col='Total_Price'):
    """
    CLTV (Customer Lifetime Value) değerlerini BG/NBD ve Gamma-Gamma modelleriyle hesaplar.
    Bu fonksiyon, işlem bazlı (transactional) veri setleri için manuel metrik türetme yapar.
    Müşterilerin büyük çoğunluğunun tek seferlik satın alma yapması durumunda özel uyarı verir.

    Args:
        dataframe (pd.DataFrame): İşlem verilerini içeren DataFrame.
        customer_id_col (str): Müşteri ID'sini içeren sütunun adı. Varsayılan: 'Customer_ID'.
        timestamp_col (str): İşlem zaman damgasını içeren sütunun adı. Varsayılan: 'Timestamp'.
        total_price_col (str): İşlem başına toplam fiyatı içeren sütunun adı. Varsayılan: 'Total_Price'.

    Returns:
        pd.DataFrame: CLTV değerleri ve segmentleri içeren DataFrame.
                      veya Hata durumunda None.
    """
    df_copy = dataframe.copy()

    print("===== CLTV Verisi Hazırlanıyor (Manuel Metrik Türetme) =====")

    if not pd.api.types.is_datetime64_any_dtype(df_copy[timestamp_col]):
        df_copy[timestamp_col] = pd.to_datetime(df_copy[timestamp_col])
        print(f"'{timestamp_col}' sütunu datetime formatına dönüştürüldü.")

    analysis_date = df_copy[timestamp_col].max() + dt.timedelta(days=1)
    print(f"Analiz tarihi belirlendi: {analysis_date.strftime('%Y-%m-%d')}")

    cltv_df = df_copy.groupby(customer_id_col).agg(
        first_order_date=(timestamp_col, 'min'),
        last_order_date=(timestamp_col, 'max'),
        # frequency: İlk satın almadan sonraki satın alma sayısı (toplam işlem sayısı - 1)
        frequency=(timestamp_col, lambda x: x.nunique() - 1),
        # monetary_cltv_avg: Müşterinin işlem başına ortalama harcaması
        monetary_cltv_avg=(total_price_col, 'mean')
    ).reset_index()

    cltv_df.rename(columns={customer_id_col: 'customer_id'}, inplace=True)

    cltv_df["recency_cltv_weekly"] = ((cltv_df["last_order_date"] - cltv_df["first_order_date"]).dt.days) / 7
    cltv_df["T_weekly"] = ((analysis_date - cltv_df["first_order_date"]).dt.days) / 7

    # --- ÖNEMLİ KONTROL: Tekrar Eden Müşteri Sayısı ---
    # BG/NBD ve Gamma-Gamma modelleri için frequency > 0 olan müşterilere ihtiyaç duyarız.
    # frequency > 0 demek, müşterinin en az 2 sipariş verdiği anlamına gelir.
    initial_customer_count = len(cltv_df)
    cltv_df_filtered = cltv_df[(cltv_df['frequency'] > 0) & (cltv_df['monetary_cltv_avg'] > 0)].copy()
    filtered_customer_count = len(cltv_df_filtered)

    print(f"Filtreleme öncesi toplam müşteri sayısı: {initial_customer_count}")
    print(f"Frekansı > 0 ve Ortalama Harcaması > 0 olan müşteri sayısı: {filtered_customer_count}")

    if filtered_customer_count < 2: # En az 2 müşteri olması lazım ki modeller anlamlı çalışsın ve qcut hata vermesin.
        print("\n!!! ÖNEMLİ UYARI: CLTV modelleri için yeterli tekrar eden müşteri bulunamadı.")
        print("Müşterilerin büyük çoğunluğu veya tamamı sadece bir kez satın alma yapmış gibi görünüyor.")
        print("Bu veri setiyle BG/NBD ve Gamma-Gamma modellerinin sağlıklı çalışması beklenmez.")
        print("CLTV tahminleri yapılamayacak ve segmentasyon anlamsız olacaktır.")
        # Boş veya uyarı içeren bir DataFrame döndür
        return pd.DataFrame(columns=['customer_id', 'cltv', 'exp_sales_3_month', 'exp_sales_6_month', 'exp_average_value', 'cltv_segment'])

    cltv_df = cltv_df_filtered # Filtrelenmiş DataFrame'i kullanmaya devam et

    print("CLTV için hazır veri yapısı (ilk 5 satır):")
    print(cltv_df.head())
    print(f"CLTV analizi için kullanılacak müşteri sayısı: {len(cltv_df)}")

    # --- BG-NBD Modelinin Kurulması ---
    print("\n===== BG/NBD Model Eğitimi =====")
    bgf = BetaGeoFitter(penalizer_coef=0.01) # Penalizer coef değerini biraz artırdık
    try:
        bgf.fit(cltv_df['frequency'],
                cltv_df['recency_cltv_weekly'],
                cltv_df['T_weekly'])
        print("BG/NBD modeli başarıyla eğitildi.")
    except Exception as e:
        print(f"BG/NBD modeli eğitilirken hata oluştu: {e}")
        print("!!! BG/NBD modeli yakınsayamadı. Veri setinizde yeterli tekrar eden satın alma davranışı olmayabilir.")
        return None

    cltv_df["exp_sales_3_month"] = bgf.predict(4 * 3,
                                               cltv_df['frequency'],
                                               cltv_df['recency_cltv_weekly'],
                                               cltv_df['T_weekly'])
    cltv_df["exp_sales_6_month"] = bgf.predict(4 * 6,
                                               cltv_df['frequency'],
                                               cltv_df['recency_cltv_weekly'],
                                               cltv_df['T_weekly'])
    print("Beklenen satışlar (3 ve 6 aylık) tahmin edildi.")

    # --- Gamma-Gamma Modelinin Kurulması ---
    print("\n===== Gamma-Gamma Model Eğitimi =====")
    ggf = GammaGammaFitter(penalizer_coef=0.01)
    try:
        ggf.fit(cltv_df['frequency'], cltv_df['monetary_cltv_avg'])
        print("Gamma-Gamma modeli başarıyla eğitildi.")
    except Exception as e:
        print(f"Gamma-Gamma modeli eğitilirken hata oluştu: {e}")
        print("!!! Gamma-Gamma modeli yakınsayamadı. Frekansı > 0 olan müşterilerin parasal değeri tutarsız olabilir.")
        return None

    cltv_df["exp_average_value"] = ggf.conditional_expected_average_profit(cltv_df['frequency'],
                                                                           cltv_df['monetary_cltv_avg'])
    print("Beklenen ortalama işlem değeri tahmin edildi.")

    # --- CLTV tahmini ---
    print("\n===== Nihai CLTV Hesaplaması =====")
    try:
        cltv = ggf.customer_lifetime_value(bgf,
                                           cltv_df['frequency'],
                                           cltv_df['recency_cltv_weekly'],
                                           cltv_df['T_weekly'],
                                           cltv_df['monetary_cltv_avg'],
                                           time=6,
                                           freq="W",
                                           discount_rate=0.01)

        cltv_df["cltv"] = cltv
        print("Toplam CLTV değerleri hesaplandı.")
    except Exception as e:
        print(f"CLTV hesaplanırken hata oluştu: {e}")
        print("!!! CLTV hesaplamasında bir sorun oluştu.")
        return None

    # --- CLTV segmentleme ---
    cltv_df = cltv_df.dropna(subset=['cltv']).copy()
    cltv_df = cltv_df[cltv_df['cltv'] != float('inf')]
    cltv_df = cltv_df[cltv_df['cltv'] != -float('inf')]

    try:
        if not cltv_df.empty and len(cltv_df['cltv'].unique()) > 1:
            cltv_df["cltv_segment"] = pd.qcut(cltv_df["cltv"], 4, labels=["D", "C", "B", "A"])
            print("\nCLTV segmentleri oluşturuldu.")
            print("CLTV segmentlerinin dağılımı:\n", cltv_df["cltv_segment"].value_counts())
            print("CLTV segmentlerinin ortalama CLTV değerleri:\n", cltv_df.groupby("cltv_segment")["cltv"].mean())
        else:
            print("Uyarı: CLTV segmentasyonu için yeterli benzersiz CLTV değeri bulunamadı (muhtemelen tek müşteri veya tüm CLTV değerleri aynı).")
            cltv_df["cltv_segment"] = "Not Segmented"
    except Exception as e:
        print(f"CLTV segmentasyonu sırasında hata oluştu: {e}")
        cltv_df["cltv_segment"] = "Error During Segmentation"
        return None

    return cltv_df[['customer_id', 'cltv', 'exp_sales_3_month', 'exp_sales_6_month', 'exp_average_value', 'cltv_segment']]

# --- Örnek Veri Yükleme ve Kullanım (Değişiklik Yok) ---
def load_and_preprocess_data(file_path, timestamp_col='Timestamp'):
    try:
        df = pd.read_csv(file_path)
        print(f"'{file_path}' başarıyla yüklendi.")
        if timestamp_col in df.columns:
            df[timestamp_col] = pd.to_datetime(df[timestamp_col])
            print(f"'{timestamp_col}' sütunu datetime formatına dönüştürüldü.")
        else:
            print(f"Uyarı: '{timestamp_col}' sütunu bulunamadı. Tarih dönüştürme atlandı.")
        return df
    except FileNotFoundError:
        print(f"Hata: '{file_path}' bulunamadı. Lütfen dosya yolunu kontrol edin.")
        return None
    except Exception as e:
        print(f"Veri yüklenirken veya ön işlenirken bir hata oluştu: {e}")
        return None

file_path = r"E:\israf\K1-20250803T110136Z-1-002\K1\simulated_pos_data_with_seasonal_trends.csv"
customer_id_col = 'Customer_ID'
timestamp_col = 'Timestamp'
total_price_col = 'Total_Price'

df_loaded = load_and_preprocess_data(file_path, timestamp_col=timestamp_col)

if df_loaded is not None:
    cltv_df_results = create_cltv_df(
        df_loaded,
        customer_id_col=customer_id_col,
        timestamp_col=timestamp_col,
        total_price_col=total_price_col
    )

    if cltv_df_results is not None:
        print("\nCLTV Analiz Sonuçları (ilk 10 satır):\n", cltv_df_results.head(10))
        print("\nCLTV Analiz Sonuçları Bilgisi:\n", cltv_df_results.info())
    else:
        print("CLTV DataFrame oluşturulamadı veya modelleme için yeterli veri bulunamadı.")
else:
    print("DataFrame yüklenemediği için CLTV analizi yapılamadı.")